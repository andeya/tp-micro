// Code generated by 'ant gen' command.
// DO NOT EDIT!

package model

import (
	"database/sql"
	"time"

	"github.com/henrylee2cn/goutil/coarsetime"
	tp "github.com/henrylee2cn/teleport"
	"github.com/xiaoenai/ants/model"
	"github.com/xiaoenai/ants/model/sqlx"
)

// User user info
type User struct {
	Id        int64  `json:"id"`
	Name      string `json:"name"`
	Age       int32  `json:"age"`
	CreatedAt int64  `json:"created_at"`
	UpdatedAt int64  `json:"updated_at"`
}

// TableName implements 'github.com/xiaoenai/ants/model'.Cacheable
func (*User) TableName() string {
	return "user"
}

var userDB, _ = dbHandler.RegCacheableDB(new(User), time.Hour*24, ``)

// GetUserDB returns the User DB handler.
func GetUserDB() *model.CacheableDB {
	return userDB
}

// InsertUser insert a User data into database.
func InsertUser(_u *User, tx ...*sqlx.Tx) (int64, error) {
	_u.UpdatedAt = coarsetime.FloorTimeNow().Unix()
	if _u.CreatedAt == 0 {
		_u.CreatedAt = _u.UpdatedAt
	}
	return _u.Id, userDB.Callback(func(tx model.DbOrTx) error {
		var query string
		if _u.Id > 0 {
			query = "INSERT INTO `user` (id,`name`,`age`,`created_at`,`updated_at`)VALUES(:id,:name,:age,:created_at,:updated_at);"
		} else {
			query = "INSERT INTO `user` (`name`,`age`,`created_at`,`updated_at`)VALUES(:name,:age,:created_at,:updated_at);"
		}
		r, err := tx.NamedExec(query, _u)
		if err != nil {
			return err
		}
		id, err := r.LastInsertId()
		if err != nil {
			return err
		}
		_u.Id = id
		err = userDB.PutCache(_u)
		if err != nil {
			tp.Errorf("%s", err.Error())
		}
		return nil
	}, tx...)
}

// UpdateUserByPrimary update the User data in database by primary key.
// NOTE:
//  _updateFields' members must be snake format;
//  Automatic update updated_at field;
//  Don't update the primary key and the created_at key;
//  Update all fields except the primary key and the created_at key if _updateFields is empty.
func UpdateUserByPrimary(_u *User, _updateFields []string, tx ...*sqlx.Tx) error {
	return userDB.Callback(func(tx model.DbOrTx) error {
		_u.UpdatedAt = coarsetime.FloorTimeNow().Unix()
		var err error
		if len(_updateFields) == 0 {
			_, err = tx.NamedExec("UPDATE `user` SET `name`=:name,`age`=:age,`updated_at`=:updated_at WHERE id=:id LIMIT 1;", _u)
		} else {
			var query = "UPDATE `user` SET "
			for _, s := range _updateFields {
				if s == "updated_at" || s == "id" || s == "created_at" {
					continue
				}
				query += "`" + s + "`=:" + s + ","
			}
			if query[len(query)-1] != ',' {
				return nil
			}
			query += "`updated_at`=:updated_at WHERE id=:id LIMIT 1;"
			_, err = tx.NamedExec(query, _u)
		}
		if err != nil {
			return err
		}
		err = userDB.PutCache(_u)
		if err != nil {
			tp.Errorf("%s", err.Error())
		}
		return nil
	}, tx...)
}

// DeleteUserByPrimary delete a User data in database by primary key.
func DeleteUserByPrimary(id int64, tx ...*sqlx.Tx) error {
	return userDB.Callback(func(tx model.DbOrTx) error {
		_, err := tx.Exec("DELETE FROM `user` WHERE id=?;", id)
		if err != nil {
			return err
		}
		err = userDB.PutCache(&User{
			Id: id,
		})
		if err != nil {
			tp.Errorf("%s", err.Error())
		}
		return nil
	}, tx...)
}

// GetUserByPrimary query a User data from database by primary key.
// If @return bool=false error=nil, means the data is not exist.
func GetUserByPrimary(id int64) (*User, bool, error) {
	var _u = &User{
		Id: id,
	}
	err := userDB.CacheGet(_u)
	switch err {
	case nil:
		if _u.CreatedAt == 0 {
			return nil, false, nil
		}
		return _u, true, nil
	case sql.ErrNoRows:
		err2 := userDB.PutCache(_u)
		if err2 != nil {
			tp.Errorf("%s", err2.Error())
		}
		return nil, false, nil
	default:
		return nil, false, err
	}
}

// GetUserByWhere query a User data from database by WHERE condition.
// If @return bool=false error=nil, means the data is not exist.
func GetUserByWhere(whereCond string, arg ...interface{}) (*User, bool, error) {
	var _u = new(User)
	err := userDB.Get(_u, "SELECT id,`name`,`age`,`created_at`,`updated_at` FROM `user` WHERE "+whereCond+" LIMIT 1;", arg...)
	switch err {
	case nil:
		return _u, true, nil
	case sql.ErrNoRows:
		return nil, false, nil
	default:
		return nil, false, err
	}
}

// SelectUserByWhere query some User data from database by WHERE condition.
func SelectUserByWhere(whereCond string, arg ...interface{}) ([]*User, error) {
	var objs = new([]*User)
	err := userDB.Select(objs, "SELECT id,`name`,`age`,`created_at`,`updated_at` FROM `user` WHERE "+whereCond, arg...)
	return *objs, err
}

// CountUserByWhere count User data number from database by WHERE condition.
func CountUserByWhere(whereCond string, arg ...interface{}) (int64, error) {
	var count int64
	err := userDB.Get(&count, "SELECT count(1) FROM `user` WHERE "+whereCond, arg...)
	return count, err
}
