// Code generated by 'ant gen' command.
// DO NOT EDIT!

package model

import (
	"database/sql"
	"time"

	"github.com/henrylee2cn/goutil/coarsetime"
	tp "github.com/henrylee2cn/teleport"
	"github.com/xiaoenai/ants/model"
	"github.com/xiaoenai/ants/model/sqlx"
)

// DivideArgs divide api args
type DivideArgs struct {
	Id int64 `json:"id"`
	// dividend
	A float64 `json:"a"`
	// divisor
	B         float64 `json:"b" param:"<range: 0.01:100000>"`
	CreatedAt int64   `json:"created_at"`
	UpdatedAt int64   `json:"updated_at"`
}

// TableName implements 'github.com/xiaoenai/ants/model'.Cacheable
func (*DivideArgs) TableName() string {
	return "divide_args"
}

var divideArgsDB, _ = dbHandler.RegCacheableDB(new(DivideArgs), time.Hour*24, ``)

// GetDivideArgsDB returns the DivideArgs DB handler.
func GetDivideArgsDB() *model.CacheableDB {
	return divideArgsDB
}

// InsertDivideArgs insert a DivideArgs data into database.
func InsertDivideArgs(_d *DivideArgs, tx ...*sqlx.Tx) (int64, error) {
	_d.UpdatedAt = coarsetime.FloorTimeNow().Unix()
	if _d.CreatedAt == 0 {
		_d.CreatedAt = _d.UpdatedAt
	}
	return _d.Id, divideArgsDB.TransactCallback(func(tx *sqlx.Tx) error {
		var query string
		if _d.Id > 0 {
			query = "INSERT INTO `divide_args` (id,`a`,`b`,`created_at`,`updated_at`)VALUES(:id,:a,:b,:created_at,:updated_at);"
		} else {
			query = "INSERT INTO `divide_args` (`a`,`b`,`created_at`,`updated_at`)VALUES(:a,:b,:created_at,:updated_at);"
		}
		r, err := tx.NamedExec(query, _d)
		if err != nil {
			return err
		}
		id, err := r.LastInsertId()
		if err != nil {
			return err
		}
		_d.Id = id
		return divideArgsDB.PutCache(_d)
	}, tx...)
}

// UpdateDivideArgsById update the DivideArgs data in database by id.
func UpdateDivideArgsById(_d *DivideArgs, tx ...*sqlx.Tx) error {
	return divideArgsDB.TransactCallback(func(tx *sqlx.Tx) error {
		_d.UpdatedAt = coarsetime.FloorTimeNow().Unix()
		_, err := tx.NamedExec("UPDATE `divide_args` SET `a`=:a,`b`=:b,`created_at`=:created_at,`updated_at`=:updated_at WHERE id=:id LIMIT 1;", _d)
		if err != nil {
			return err
		}
		return divideArgsDB.PutCache(_d)
	}, tx...)
}

// DeleteDivideArgsById delete a DivideArgs data in database by id.
func DeleteDivideArgsById(id int64, tx ...*sqlx.Tx) error {
	return divideArgsDB.TransactCallback(func(tx *sqlx.Tx) error {
		_, err := tx.Exec("DELETE FROM `divide_args` WHERE id=?;", id)
		if err != nil {
			return err
		}
		return divideArgsDB.PutCache(&DivideArgs{
			Id: id,
		})
	}, tx...)
}

// GetDivideArgsById query a DivideArgs data from database by id.
// If @reply bool=false error=nil, means the data is not exist.
func GetDivideArgsById(id int64) (*DivideArgs, bool, error) {
	var _d = &DivideArgs{
		Id: id,
	}
	err := divideArgsDB.CacheGet(_d)
	switch err {
	case nil:
		if _d.CreatedAt == 0 {
			return nil, false, nil
		}
		return _d, true, nil
	case sql.ErrNoRows:
		err2 := divideArgsDB.PutCache(_d)
		if err2 != nil {
			tp.Errorf("%s", err2.Error())
		}
		return nil, false, nil
	default:
		return nil, false, err
	}
}

// GetDivideArgsByWhere query a DivideArgs data from database by WHERE condition.
// If @reply bool=false error=nil, means the data is not exist.
func GetDivideArgsByWhere(whereCond string, args ...interface{}) (*DivideArgs, bool, error) {
	var _d = new(DivideArgs)
	err := divideArgsDB.Get(_d, "SELECT id,`a`,`b`,`created_at`,`updated_at` FROM `divide_args` WHERE "+whereCond+" LIMIT 1;", args...)
	switch err {
	case nil:
		return _d, true, nil
	case sql.ErrNoRows:
		return nil, false, nil
	default:
		return nil, false, err
	}
}

// SelectDivideArgsByWhere query some DivideArgs data from database by WHERE condition.
func SelectDivideArgsByWhere(whereCond string, args ...interface{}) ([]*DivideArgs, error) {
	var objs = new([]*DivideArgs)
	err := divideArgsDB.Select(objs, "SELECT id,`a`,`b`,`created_at`,`updated_at` FROM `divide_args` WHERE "+whereCond, args...)
	return *objs, err
}

// CountDivideArgsByWhere count DivideArgs data number from database by WHERE condition.
func CountDivideArgsByWhere(whereCond string, args ...interface{}) (int64, error) {
	var count int64
	err := divideArgsDB.Get(&count, "SELECT count(1) FROM `divide_args` WHERE "+whereCond, args...)
	return count, err
}
