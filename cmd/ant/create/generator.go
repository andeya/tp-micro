package create

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"unicode"

	"github.com/henrylee2cn/ant"
	"github.com/henrylee2cn/ant/cmd/ant/info"
	"github.com/henrylee2cn/goutil"
)

const (
	// API_PULL_ROUTER Name of the interface used to register the pull route in the template
	API_PULL_ROUTER = "__API__PULL__"
	// API_PUSH_ROUTER Name of the interface used to register the push route in the template
	API_PUSH_ROUTER = "__API__PUSH__"
)

type (
	// Project project Information
	Project struct {
		fileSet      *token.FileSet
		astFile      *ast.File
		Name         string
		ImprotPrefix string
		Types        []*TypeStructGroup
		CtrlStructs  map[string]*CtrlStruct
		PullApis     []*Handler
		PushApis     []*Handler
	}
	// TypeStructGroup a group of defined types
	TypeStructGroup struct {
		Doc     string
		Structs []*TypeStruct
	}
	// TypeStruct defined struct in types directory
	TypeStruct struct {
		Doc  string
		Name string
		Body string
	}
	// CtrlStruct defined controller struct
	CtrlStruct struct {
		Doc     string
		Name    string
		Methods []*Handler
	}
	// Handler defined router handler
	Handler struct {
		IsCtrl bool
		Name   string
		Doc    string
		Param  string
		Result string
	}
)

// NewProject new project.
func NewProject(src []byte) *Project {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "", src, parser.ParseComments)
	if err != nil {
		ant.Fatalf("[ant] %v", err)
	}

	var proj Project
	proj.CtrlStructs = make(map[string]*CtrlStruct)
	proj.Name = info.ProjName()
	proj.ImprotPrefix = info.ProjPath()
	proj.fileSet = fset
	proj.astFile = file

	return &proj
}

// Prepare prepares project.
func (p *Project) Prepare() {
	for k, v := range codeFiles {
		v = strings.Replace(v, "${import_prefix}", p.ImprotPrefix, -1)
		if k == "logic/tmp_code.gen.go" {
			codeFiles[k] = "// Code generated by 'ant gen' command.\n// The temporary code used to ensure successful compilation!\n\n" + v
		} else {
			codeFiles[k] = "// Code generated by 'ant gen' command.\n// DO NOT EDIT!\n\n" + v
		}
	}

	for _, decl := range p.astFile.Decls {
		genDecl := decl.(*ast.GenDecl)

		var typeStructGroup = &TypeStructGroup{
			Doc: groupComment(genDecl.Doc.Text()),
		}

		for _, spec := range genDecl.Specs {

			typeSpec := spec.(*ast.TypeSpec)
			name := typeSpec.Name.Name
			var doc = typeStructGroup.Doc
			if len(genDecl.Specs) > 1 {
				doc = comment(name, typeSpec.Doc.Text(), typeSpec.Comment.Text())
			}

			switch t := typeSpec.Type.(type) {

			case *ast.StructType:
				// types
				if !goutil.IsExportedName(name) {
					ant.Fatalf("[ant] Unexported types: %s", name)
				}
				dst := bytes.NewBuffer(nil)
				format.Node(dst, p.fileSet, typeSpec.Type)
				body := dst.String()
				typeStructGroup.Structs = append(typeStructGroup.Structs, &TypeStruct{
					Name: name,
					Doc:  doc,
					Body: body,
				})

			case *ast.InterfaceType:

				var handlers []*Handler

				for _, method := range t.Methods.List {

					switch tt := method.Type.(type) {
					case *ast.FuncType:
						// function
						subName := method.Names[0].String()
						if tt.Params.NumFields() != 1 {
							ant.Fatalf("[ant] Invalid method: %s", subName)
							continue
						}
						dst := bytes.NewBuffer(nil)
						format.Node(dst, p.fileSet, tt.Params.List[0].Type)
						param := dst.String()

						var result string
						if n := tt.Results.NumFields(); n > 1 {
							ant.Fatalf("[ant] Invalid method: %s", subName)
						} else if n == 1 {
							dst.Reset()
							format.Node(dst, p.fileSet, tt.Results.List[0].Type)
							result = dst.String()
						}

						r := &Handler{
							IsCtrl: false,
							Name:   subName,
							Doc:    comment(subName, method.Doc.Text(), method.Comment.Text()),
							Param:  param,
							Result: result,
						}
						handlers = append(handlers, r)

					case *ast.Ident:
						// interface
						subName := tt.String()
						r := &Handler{
							IsCtrl: true,
							Name:   subName,
							Doc:    comment(subName, method.Doc.Text(), method.Comment.Text()),
						}
						handlers = append(handlers, r)
					}
				}

				switch name {
				case API_PULL_ROUTER:
					p.PullApis = append(p.PullApis, handlers...)

				case API_PUSH_ROUTER:
					p.PushApis = append(p.PushApis, handlers...)

				default:
					// controller
					p.CtrlStructs[name] = &CtrlStruct{
						Name:    name,
						Doc:     doc,
						Methods: handlers,
					}
				}
			}
		}

		if len(typeStructGroup.Structs) > 0 {
			p.Types = append(p.Types, typeStructGroup)
		}
	}
}

var codeFiles = map[string]string{
	"types/types.gen.go": `package types
${type_define_list}
`,

	"logic/tmp_code.gen.go": `package logic
import (
	tp "github.com/henrylee2cn/teleport"
	"${import_prefix}/types"
)
${logic_api_define}
`,

	"api/handler.gen.go": `package api
import (
    "${import_prefix}/logic"
    "${import_prefix}/types"
    tp "github.com/henrylee2cn/teleport"
)
${handler_api_define}
`,

	"api/router.gen.go": `
package api
import (
    tp "github.com/henrylee2cn/teleport"
)
// Route registers handlers to router.
func Route(root string, router *tp.Router) {
    // root router group
    group := router.SubRoute(root)
    
    // custom router
    customRoute(group.ToRouter())
   
    // automatically generated router
    ${register_router_list}}
`,

	"sdk/rpc.gen.go": `package sdk
import (
	"github.com/henrylee2cn/ant"
	"${import_prefix}/types"
	tp "github.com/henrylee2cn/teleport"
	"github.com/henrylee2cn/teleport/socket"
)
var client *ant.Client
// Init init client with config and linker.
func Init(cliConfig ant.CliConfig, linker ant.Linker) {
	client = ant.NewClient(
		cliConfig,
		linker,
	)
}
// InitWithClient init client with current client.
func InitWithClient(cli *ant.Client) {
	client = cli
}
${rpc_call_define}
`,

	"sdk/rpc_test.gen.go": `package sdk
import (
	"testing"
	"github.com/henrylee2cn/ant"
	"${import_prefix}/types"
)

// TestSdk test SDK.
func TestSdk(t *testing.T) {
	Init(
		ant.CliConfig{
			Failover:        3,
			HeartbeatSecond: 4,
		},
		ant.NewStaticLinker(":9090"),
	)
	${rpc_call_test_define}}
`}

func mustMkdirAll(dir string) {
	err := os.MkdirAll(dir, os.ModePerm)
	if err != nil {
		ant.Fatalf("[ant] %v", err)
	}
}

// Generator generates code files.
func (p *Project) Generator() {
	// generate all codes
	p.genTypesFile()
	p.genRouterFile()
	p.genHandlerAndLogicAndSdkFiles()
	// make all directorys
	mustMkdirAll("types")
	mustMkdirAll("api")
	mustMkdirAll("logic")
	mustMkdirAll("sdk")
	// write files
	for k, v := range codeFiles {
		f, err := os.OpenFile(k, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)
		if err != nil {
			ant.Fatalf("[ant] Create files error: %v", err)
		}
		f.WriteString(v)
		f.Close()
		fmt.Printf("generate %s\n", info.ProjPath()+"/"+k)
	}
}

func (p *Project) genTypesFile() {
	var s string
	for _, t := range p.Types {
		s += t.createCode()
	}
	replace("types/types.gen.go", "${type_define_list}", s)
}

func (p *Project) genRouterFile() {
	var s string
	if len(p.PullApis) > 0 {
		s += "\n// PULL APIs...\n"
		for _, r := range p.PullApis {
			if r.IsCtrl {
				s += fmt.Sprintf("group.RoutePull(&%s{})\n", r.Name)
			} else {
				s += fmt.Sprintf("group.RoutePullFunc(%s)\n", r.Name)
			}
		}
	}
	if len(p.PushApis) > 0 {
		s += "\n// PUSH APIs...\n"
		for _, r := range p.PushApis {
			if r.IsCtrl {
				s += fmt.Sprintf("group.RoutePush(&%s{})\n", r.Name)
			} else {
				s += fmt.Sprintf("group.RoutePushFunc(%s)\n", r.Name)
			}
		}
	}
	replace("api/router.gen.go", "${register_router_list}", s)
}

func (p *Project) genHandlerAndLogicAndSdkFiles() {
	var handler, logic, sdk, sdkTest = p.createHandlerAndLogicAndSdk(p.PullApis, true)
	var a, b, c, d = p.createHandlerAndLogicAndSdk(p.PushApis, false)
	handler += a
	logic += b
	sdk += c
	sdkTest += d
	replace("api/handler.gen.go", "${handler_api_define}", handler)
	replace("logic/tmp_code.gen.go", "${logic_api_define}", logic)
	replace("sdk/rpc.gen.go", "${rpc_call_define}", sdk)
	replace("sdk/rpc_test.gen.go", "${rpc_call_test_define}", sdkTest)
}

func (p *Project) createHandlerAndLogicAndSdk(routers []*Handler, isPull bool) (handler, logic, sdk, sdkTest string) {
	for _, r := range routers {
		if !r.IsCtrl {
			a, b, c, d := p.createFunc(r, isPull)
			handler += a
			logic += b
			sdk += c
			sdkTest += d
		} else {
			c, ok := p.CtrlStructs[r.Name]
			if ok {
				if c.Doc == "" {
					c.Doc = r.Doc
				}
				a, b, c, d := p.createCtrlStruct(c, isPull)
				handler += a
				logic += b
				sdk += c
				sdkTest += d
			}
		}
	}
	return
}

func (p *Project) createFunc(r *Handler, isPull bool) (handler, logic, sdk, sdkTest string) {
	paramAndresult := p.checkHandler(r, isPull)
	camelName := goutil.CamelString(r.Name)
	camelDoc := strings.Replace(r.Doc, "// "+r.Name, "// "+camelName, 1)
	if isPull {
		return fmt.Sprintf(
				"%sfunc %s(ctx tp.PullCtx,args %s)(%s,*tp.Rerror){\nreturn logic.%s(ctx,args)\n}\n",
				r.Doc, r.Name, paramAndresult[0], paramAndresult[1], camelName,
			), fmt.Sprintf(
				"%sfunc %s(ctx tp.PullCtx,args %s)(%s,*tp.Rerror){\nreturn &%s{},nil\n}\n",
				camelDoc, camelName, paramAndresult[0], paramAndresult[1], paramAndresult[1][1:],
			), fmt.Sprintf(
				"%sfunc %s(args %s, setting ...socket.PacketSetting)(%s,*tp.Rerror){\n"+
					"reply := new(%s)\n"+
					"rerr := client.Pull(\"/%s/%s\", args, reply, setting...).Rerror()\n"+
					"return reply, rerr\n}\n",
				camelDoc, camelName, paramAndresult[0], paramAndresult[1],
				paramAndresult[1][1:],
				goutil.SnakeString(p.Name), goutil.SnakeString(r.Name),
			), fmt.Sprintf(
				"{\n"+
					"reply, rerr :=%s(&%s{})\n"+
					"if rerr != nil {\nt.Logf(\"rerr: %%v\", rerr)\n} else {\nt.Logf(\"reply: %%v\", reply)\n}\n"+
					"}\n",
				camelName, paramAndresult[0][1:],
			)

	} else {
		return fmt.Sprintf(
				"%sfunc %s(ctx tp.PushCtx,args %s)*tp.Rerror{\nreturn logic.%s(ctx,args)\n}\n",
				r.Doc, r.Name, paramAndresult[0], camelName,
			), fmt.Sprintf(
				"%sfunc %s(ctx tp.PushCtx,args %s)*tp.Rerror{\nreturn nil\n}\n",
				camelDoc, camelName, paramAndresult[0],
			), fmt.Sprintf(
				"%sfunc %s(args %s, setting ...socket.PacketSetting)*tp.Rerror{\n"+
					"return client.Push(\"/%s/%s\", args, setting...)\n"+
					"}\n",
				camelDoc, camelName, paramAndresult[0],
				goutil.SnakeString(p.Name), goutil.SnakeString(r.Name),
			), fmt.Sprintf(
				"{\n"+
					"rerr :=%s(&%s{})\n"+
					"t.Logf(\"rerr: %%v\", rerr)\n"+
					"}\n",
				camelName, paramAndresult[0][1:],
			)
	}
}

func (p *Project) createCtrlStruct(c *CtrlStruct, isPull bool) (handler, logic, sdk, sdkTest string) {
	var ctx string
	if isPull {
		ctx = "tp.PullCtx"
	} else {
		ctx = "tp.PushCtx"
	}
	handler += fmt.Sprintf("%stype %s struct{\n%s\n}\n\n", c.Doc, c.Name, ctx)
	for _, r := range c.Methods {
		a, b, c, d := p.createMethod(c.Name, r, isPull)
		handler += a
		logic += b
		sdk += c
		sdkTest += d
	}
	return
}

func (p *Project) createMethod(ctrl string, r *Handler, isPull bool) (handler, logic, sdk, sdkTest string) {
	paramAndresult := p.checkHandler(r, isPull)
	first := strings.ToLower(ctrl[:1])
	fullName := goutil.CamelString(ctrl + "_" + r.Name)
	fullDoc := strings.Replace(r.Doc, "// "+r.Name, "// "+fullName, 1)
	if isPull {
		return fmt.Sprintf(
				"%sfunc(%s *%s) %s(args %s)(%s,*tp.Rerror){\nreturn logic.%s(%s.PullCtx,args)\n}\n",
				r.Doc, first, ctrl, r.Name, paramAndresult[0], paramAndresult[1], fullName, first,
			), fmt.Sprintf(
				"%sfunc %s(ctx tp.PullCtx,args %s)(%s,*tp.Rerror){\nreturn &%s{},nil\n}\n",
				fullDoc, fullName, paramAndresult[0], paramAndresult[1], paramAndresult[1][1:],
			), fmt.Sprintf(
				"%sfunc %s(args %s, setting ...socket.PacketSetting)(%s,*tp.Rerror){\n"+
					"reply := new(%s)\n"+
					"rerr := client.Pull(\"/%s/%s/%s\", args, reply, setting...).Rerror()\n"+
					"return reply, rerr\n}\n",
				fullDoc, fullName, paramAndresult[0], paramAndresult[1],
				paramAndresult[1][1:],
				goutil.SnakeString(p.Name), goutil.SnakeString(ctrl), goutil.SnakeString(r.Name),
			), fmt.Sprintf(
				"{\n"+
					"reply, rerr :=%s(&%s{})\n"+
					"if rerr != nil {\nt.Logf(\"rerr: %%v\", rerr)\n} else {\nt.Logf(\"reply: %%v\", reply)\n}\n"+
					"}\n",
				fullName, paramAndresult[0][1:],
			)

	} else {
		return fmt.Sprintf(
				"%sfunc(%s *%s) %s(args %s)*tp.Rerror{\nreturn logic.%s(%s.PushCtx,args)\n}\n",
				r.Doc, first, ctrl, r.Name, paramAndresult[0], fullName, first,
			), fmt.Sprintf(
				"%sfunc %s(ctx tp.PushCtx,args %s)*tp.Rerror{\nreturn nil\n}\n",
				fullDoc, fullName, paramAndresult[0],
			), fmt.Sprintf(
				"%sfunc %s(args %s, setting ...socket.PacketSetting)*tp.Rerror{\n"+
					"return client.Push(\"/%s/%s/%s\", args, setting...)\n"+
					"}\n",
				fullDoc, fullName, paramAndresult[0],
				goutil.SnakeString(p.Name), goutil.SnakeString(ctrl), goutil.SnakeString(r.Name),
			), fmt.Sprintf(
				"{\n"+
					"rerr :=%s(&%s{})\n"+
					"t.Logf(\"rerr: %%v\", rerr)\n"+
					"}\n",
				fullName, paramAndresult[0][1:],
			)
	}
}

func (t *TypeStructGroup) createCode() (s string) {
	defer func() {
		b, _ := format.Source([]byte(s))
		s = string(b)
	}()
	switch a := len(t.Structs); {
	case a == 0:
		return ""
	case a == 1:
		tt := t.Structs[0]
		doc := t.Doc
		if doc == "" {
			doc = tt.Doc
		}
		return fmt.Sprintf("\n%stype %s %s\n", doc, tt.Name, addTag(tt.Body))
	default:
		var body string
		for _, tt := range t.Structs {
			body += fmt.Sprintf("%s%s %s\n\n", tt.Doc, tt.Name, addTag(tt.Body))
		}
		return fmt.Sprintf("\n%stype(\n%s)\n", t.Doc, body)
	}
}

func addTag(body string) string {
	a := strings.Split(body, "\n")
	for i, s := range a {
		if i == 0 || i == len(a)-1 {
			continue
		}
		s = strings.TrimSpace(s)
		if s[0] == '/' {
			continue
		}
		var lastIsSpace bool
		var cnt int
		var col [4]string
		for _, r := range s {
			if unicode.IsSpace(r) {
				if !lastIsSpace {
					cnt++
				}
				lastIsSpace = true
			} else {
				lastIsSpace = false
				col[cnt] += string(r)
			}
		}
		jsTag := fmt.Sprintf("json:\"%s\"", goutil.SnakeString(col[0]))
		if col[2] == "" {
			col[2] = "`" + jsTag + "`"
		} else if col[2][0] == '/' {
			col[3] = col[2] + " " + col[3]
			col[2] = "`" + jsTag + "`"
		} else if !strings.Contains(col[2], "json:\"") {
			col[2] = col[2][:1] + jsTag + " " + col[2][1:]
		}
		a[i] = strings.Join(col[:], " ")
	}
	return strings.Join(a, "\n")
}

func groupComment(s string) string {
	s = strings.TrimSpace(s)
	if len(s) == 0 {
		return ""
	}
	return "// " + strings.Replace(s, "\n", "\n// ", -1) + "\n"
}

func comment(name, s1, s2 string) string {
	s := s1
	if s == "" {
		s = s2
	}
	s = groupComment(s)
	if len(s) == 0 {
		return "// " + name + " comment...\n"
	}
	return s
}

func (p *Project) checkHandler(r *Handler, isPull bool) (paramAndResult [2]string) {
	var tt = []string{r.Param}
	if isPull {
		if r.Result == "" {
			panic("Pull Handler mush have result: " + r.Name)
		}
		tt = append(tt, r.Result)
	} else {
		if r.Result != "" {
			panic("Push Handler must not have result: " + r.Name)
		}
	}
	for i, t := range tt {
		if len(t) < 2 || t[0] != '*' {
			panic("Arguments and results must be exised struct pointers: " + r.Name)
		}
		if t == "*struct{}" {
			paramAndResult[i] = t
		} else {
			name := t[1:]

		Q:
			for _, ty := range p.Types {
				for _, s := range ty.Structs {
					if s.Name == name {
						paramAndResult[i] = t[:1] + "types." + name
						break Q
					}
				}
			}
			if paramAndResult[i] == "" {
				panic("Arguments and results must be exised struct pointers: " + r.Name)
			}
		}
	}
	return
}

func replace(key, placeholder, value string) string {
	a := strings.Replace(codeFiles[key], placeholder, "\n"+value, -1)
	b := formatSource(goutil.StringToBytes(a))
	c := goutil.BytesToString(b)
	codeFiles[key] = c
	return c
}

func formatSource(src []byte) []byte {
	b, err := format.Source(src)
	if err != nil {
		panic(err.Error())
	}
	return b
}
